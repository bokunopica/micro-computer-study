# RDBMS
```sql
-- SQL语句
-- 建表 CREATE TABLE
CREATE TABLE 表名
(
  列名1 数据类型 [列级完整性约束条件],
  ....
  列名n 数据类型 [列级完整性约束条件],
  表级完整性约束条件1,
  ...
  表级完整性约束条件n
);

-- 数据类型
CHAR(n) 长度为n的字符串
VARCHAR(n) 最大长度为n的变长字符串
NUMBER(n) 长度为n的数字型
INT 整型(4b)
BIGINT 长整型(8b)
SMALLINT 短整型(2b)
FLOAT(n) 精度位n位数字的浮点型
DATE 日期yyyy-mm-dd
TIME 时间HH:MM:SS
-- 列级完整性约束条件
PRIMARY KEY 主键，只有1个主码时可以直接写
NOT NULL 非空
UNIQUE 唯一
CHECK(条件)
-- 表级完整性约束条件
PRIMARY KEY(列名1, ..., 列名n)
FOREIGN KEY(列名1) REFERENCES 被参照表(列名1)

-- example of create table
CREATE TABLE Stu
(
  id int AUTO_INCREMENT,
  s_name varchar(20),
  mobile char(20),
  create_time datetime,
  update_time datetime,
  is_delete tinyint,
  PRIMARY KEY(id),
  FOREIGN KEY(id) REFERENCES CourseChosen(s_id)
);

-- 修改表 ALTER TABLE
-- 1.增加新的属性列
ALTER TABLE Stu ADD class_id int;
-- 2.增加列级完整性约束条件
ALTER TABLE Stu ADD UNIQUE(mobile);
-- 3.增加表级完整性约束条件
ALTER TABLE Stu ADD FOREIGN KEY(mobile) REFERENCES ContactInfo(mobile);
-- 4.删除列
ALTER TABLE Stu DROP class_id CASCADE; // 级联删除 引用该列的其他对象一起删
ALTER TABLE Stu DROP class_id RESTRICT; // 若该列被其他对象引用则拒绝删除
-- 5.删除列级完整性约束条件
ALTER TABLE Stu DROP CONSTRAINT UNIQUE(mobil) CASCADE;
ALTER TABLE Stu DROP CONSTRAINT UNIQUE(mobil) RESTRICT;
-- 6.修改列
ALTER TABLE Stu ALTER mobile phone varchar(20);


-- 建立索引
-- 1.建立唯一索引
CREATE UNIQUE INDEX ID_NAME ON Stu(id asc, s_name asc);
-- 2.建立聚簇索引
CREATE CLUSTER INDEX ID_NAME ON Stu(id asc, s_name asc);
-- 3.改索引名
Alter INDEX ID_NAME RENAME TO ID_NAME_RENAME;
-- 4.删索引
DROP INDEX ID_NAME;

-- 插入数据 INSERT INTO
INSERT INTO Stu(s_name, mobile) VALUES('qq', 185****9720);

-- 更新数据
UPDATE Stu SET s_name='qqq', mobile='11111111111' where id = 1;

-- 删除数据
DELETE FROM Stu WHERE id = 1;




-- 查询
-- 关键字排序
1、from 子句组装来自不同数据源的数据；
2、where 子句基于指定的条件对记录行进行筛选； 
3、group by 子句将数据划分为多个分组； 
4、使用聚集函数进行计算； 
5、使用 having 子句筛选分组； 
6、计算所有的表达式； 
7、select 的字段； 
8、使用 order by 对结果集进行排序。
9、offset,limit分页


-- 聚集函数
count(), count(distinct col),avg(), sum(), max(), min()

-- where条件表达式
where col in ('a', 'b', 'c')
where a between 0 and 10
where col > 1
where s_name like "刘%"


-- 集合查询
UNION 并
INTERSECT 交
EXCEPT 差
```
- 事务
- 封锁
  - X锁 排他锁
    - 写锁，事务对数据对象上锁后，可读取和修改该数据对象，其他事务不可再对该数据对象添加锁
  - S锁 共享锁
    - 读锁，某事物对数据对象上锁后，可读取但不可修改该数据对象，其他事务对该数据对象添加s锁，但不能添加x锁
- 封锁协议
  - 一级封锁协议
    - 写前加锁，事务结束释放写锁，防止丢失修改
  - 二级...
    - 写前加写锁，读前加读锁，读完释放读锁，事务结束释放写锁，防止丢失修改和读脏数据
  - 三级...
    - 写前加写锁，读前加读锁，事务结束释放各锁，可防止丢失修改、读脏数据和不可重复读



# Redis
- 内存数据库
- 可以持久化到硬盘
  - 触发命令
      - save 阻塞当前进程 进行持久化
      - bgsave 主进程fork一个子进程来执行RDB过程 完成后自动结束
  - 触发机制
      - 自动触发 
      - 配置redis.conf的自动触发条件
      - shutdown关闭时未开启AOF持久化功能，自动执行一次bgsave
      - 主从同步
      - 手动触发 
  - 持久化类型
      - RDB redis内存快照
        - 文件小 适合定时备份 用于灾难恢复 RDB加载速度也快
        - 实时性差 无法实时持久化 会阻塞进程
      - AOF日志
        - AOF日志是持续增量的备份，是基于写命令存储的可读的文本文件。AOF日志会在持续运行中持续增大，由于Redis重启过程需要优先加载AOF日志进行指令重放以恢复数据，恢复时间会无比漫长。所以需要定期进行AOF重写，对AOF日志进行瘦身。目前AOF是Redis持久化的主流方式。
        - AOF是文件操作，对于变更操作比较密集的server，那么将造成磁盘IO的负荷加重。此外linux对文件操作采取了“延迟写入”手段，即并非每次write操作都会触发实际磁盘操作，而是进入了buffer中，当buffer数据达到阀值时触发实际写入(也有其他时机)，这是linux对文件系统的优化。
        - 优点：AOF只是追加写日志文件，对服务器性能影响较小，速度比RDB要快，消耗的内存较少
        - 缺点：
            - AOF方式生成的日志文件太大，需要不断AOF重写，进行瘦身。
            - 即使经过AOF重写瘦身，由于文件是文本文件，文件体积较大（相比于RDB的二进制文件）。
            - AOF重演命令式的恢复数据，速度显然比RDB要慢。

  - 数据结构
<table>
    <thead><tr>
    <th>类型</th>
    <th>简介</th>
    <th>特性</th>
    <th>场景</th>
    </tr></thead>
    <tbody>
    <tr>
    <td>String(字符串)</td>
    <td>二进制安全</td>
    <td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td>
    <td>简单的缓存/ setnx 用来做简单的锁</td>
    </tr>
    <tr>
    <td>Hash(字典)</td>
    <td>键值对集合,即编程语言中的Map类型</td>
    <td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td>
    <td>存储、读取、修改用户属性</td>
    </tr>
    <tr>
    <td>List(列表)</td>
    <td>链表(双向链表)</td>
    <td>增删快,提供了操作某一段元素的API</td>
    <td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td>
    </tr>
    <tr>
    <td>Set(集合)</td>
    <td>哈希表实现,元素不重复</td>
    <td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td>
    <td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td>
    </tr>
    <tr>
    <td>Sorted Set(有序集合)</td>
    <td>将Set中的元素增加一个权重参数score,元素按score有序排列</td>
    <td>数据插入集合时,已经进行天然排序</td>
    <td>1、排行榜 2、带权重的消息队列</td>
    </tr>
    </tbody>
</table>

