# Redis
- 内存数据库
- 可以持久化到硬盘
  - 触发命令
      - save 阻塞当前进程 进行持久化
      - bgsave 主进程fork一个子进程来执行RDB过程 完成后自动结束
  - 触发机制
      - 自动触发 
      - 配置redis.conf的自动触发条件
      - shutdown关闭时未开启AOF持久化功能，自动执行一次bgsave
      - 主从同步
      - 手动触发 
  - 持久化类型
      - RDB redis内存快照
        - 文件小 适合定时备份 用于灾难恢复 RDB加载速度也快
        - 实时性差 无法实时持久化 会阻塞进程
      - AOF日志
        - AOF日志是持续增量的备份，是基于写命令存储的可读的文本文件。AOF日志会在持续运行中持续增大，由于Redis重启过程需要优先加载AOF日志进行指令重放以恢复数据，恢复时间会无比漫长。所以需要定期进行AOF重写，对AOF日志进行瘦身。目前AOF是Redis持久化的主流方式。
        - AOF是文件操作，对于变更操作比较密集的server，那么将造成磁盘IO的负荷加重。此外linux对文件操作采取了“延迟写入”手段，即并非每次write操作都会触发实际磁盘操作，而是进入了buffer中，当buffer数据达到阀值时触发实际写入(也有其他时机)，这是linux对文件系统的优化。
        - 优点：AOF只是追加写日志文件，对服务器性能影响较小，速度比RDB要快，消耗的内存较少
        - 缺点：
            - AOF方式生成的日志文件太大，需要不断AOF重写，进行瘦身。
            - 即使经过AOF重写瘦身，由于文件是文本文件，文件体积较大（相比于RDB的二进制文件）。
            - AOF重演命令式的恢复数据，速度显然比RDB要慢。

  - 数据结构
<table>
    <thead><tr>
    <th>类型</th>
    <th>简介</th>
    <th>特性</th>
    <th>场景</th>
    </tr></thead>
    <tbody>
    <tr>
    <td>String(字符串)</td>
    <td>二进制安全</td>
    <td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td>
    <td>简单的缓存/ setnx 用来做简单的锁</td>
    </tr>
    <tr>
    <td>Hash(字典)</td>
    <td>键值对集合,即编程语言中的Map类型</td>
    <td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td>
    <td>存储、读取、修改用户属性</td>
    </tr>
    <tr>
    <td>List(列表)</td>
    <td>链表(双向链表)</td>
    <td>增删快,提供了操作某一段元素的API</td>
    <td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td>
    </tr>
    <tr>
    <td>Set(集合)</td>
    <td>哈希表实现,元素不重复</td>
    <td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td>
    <td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td>
    </tr>
    <tr>
    <td>Sorted Set(有序集合)</td>
    <td>将Set中的元素增加一个权重参数score,元素按score有序排列</td>
    <td>数据插入集合时,已经进行天然排序</td>
    <td>1、排行榜 2、带权重的消息队列</td>
    </tr>
    </tbody>
</table>

mongoDB