# 数据库
## RDBMS
- 事务
  - A. 事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.
  - C. 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.
  - I. 独立性(Isolation):事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.
  - D. 持久性(Durability):事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.

- 索引
  - 索引是对数据库表中一列或多列的值进行排序的一种结构。
  - 优缺点
    - 索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要的原因。
    - 创建索引和维护索引要耗费时间和空间，这种时间随着数据量的增加而增加，对表中的数据进行增、删、改的时候，索引也要动态的维护。
  - 索引类型
    - B-Tree
      - 平衡树 Balanced Tree
      - 其搜索性能等价于在关键字全集内做一次二分查找；
      - 搜索有可能在非叶子结点结束；
      - ![](img/b_tree.png)
    - B+Tree
      - 平衡树改良版本
      - 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
      - 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
      - ![](img/b+tree.png)
    - Hash
      - 散列函数索引
      - 仅仅能满足"=",“IN"和”<=>"查询，不能使用范围查询。也不支持任何范围查询，例如WHERE price > 100。
      - ![](img/index_hash.png)
```sql
-- SQL语句
-- 建表 CREATE TABLE
CREATE TABLE 表名
(
  列名1 数据类型 [列级完整性约束条件],
  ....
  列名n 数据类型 [列级完整性约束条件],
  表级完整性约束条件1,
  ...
  表级完整性约束条件n
);

-- 数据类型
CHAR(n) 长度为n的字符串
VARCHAR(n) 最大长度为n的变长字符串
NUMBER(n) 长度为n的数字型
INT 整型(4b)
BIGINT 长整型(8b)
SMALLINT 短整型(2b)
FLOAT(n) 精度位n位数字的浮点型
DATE 日期yyyy-mm-dd
TIME 时间HH:MM:SS
-- 列级完整性约束条件
PRIMARY KEY 主键，只有1个主码时可以直接写
NOT NULL 非空
UNIQUE 唯一
CHECK(条件)
-- 表级完整性约束条件
PRIMARY KEY(列名1, ..., 列名n)
FOREIGN KEY(列名1) REFERENCES 被参照表(列名1)

-- example of create table
CREATE TABLE Stu
(
  id int AUTO_INCREMENT,
  s_name varchar(20),
  mobile char(20),
  create_time datetime,
  update_time datetime,
  is_delete tinyint,
  PRIMARY KEY(id),
  FOREIGN KEY(id) REFERENCES CourseChosen(s_id)
);

-- 修改表 ALTER TABLE
-- 1.增加新的属性列
ALTER TABLE Stu ADD class_id int;
-- 2.增加列级完整性约束条件
ALTER TABLE Stu ADD UNIQUE(mobile);
-- 3.增加表级完整性约束条件
ALTER TABLE Stu ADD FOREIGN KEY(mobile) REFERENCES ContactInfo(mobile);
-- 4.删除列
ALTER TABLE Stu DROP class_id CASCADE; // 级联删除 引用该列的其他对象一起删
ALTER TABLE Stu DROP class_id RESTRICT; // 若该列被其他对象引用则拒绝删除
-- 5.删除列级完整性约束条件
ALTER TABLE Stu DROP CONSTRAINT UNIQUE(mobil) CASCADE;
ALTER TABLE Stu DROP CONSTRAINT UNIQUE(mobil) RESTRICT;
-- 6.修改列
ALTER TABLE Stu ALTER mobile phone varchar(20);


-- 建立索引
-- 1.建立唯一索引
CREATE UNIQUE INDEX ID_NAME ON Stu(id asc, s_name asc);
-- 2.建立聚簇索引
CREATE CLUSTER INDEX ID_NAME ON Stu(id asc, s_name asc);
-- 3.改索引名
Alter INDEX ID_NAME RENAME TO ID_NAME_RENAME;
-- 4.删索引
DROP INDEX ID_NAME;

-- 插入数据 INSERT INTO
INSERT INTO Stu(s_name, mobile) VALUES('qq', 185****9720);

-- 更新数据
UPDATE Stu SET s_name='qqq', mobile='11111111111' where id = 1;

-- 删除数据
DELETE FROM Stu WHERE id = 1;




-- 查询
-- 关键字排序
1、from 子句组装来自不同数据源的数据；
2、where 子句基于指定的条件对记录行进行筛选； 
3、group by 子句将数据划分为多个分组； 
4、使用聚集函数进行计算； 
5、使用 having 子句筛选分组； 
6、计算所有的表达式； 
7、select 的字段； 
8、使用 order by 对结果集进行排序。
9、offset,limit分页


-- 聚集函数
count(), count(distinct col),avg(), sum(), max(), min()

-- where条件表达式
where col in ('a', 'b', 'c')
where a between 0 and 10
where col > 1
where s_name like "刘%"


-- 集合查询
UNION 并
INTERSECT 交
EXCEPT 差
```
- 事务
- 封锁
  - X锁 排他锁
    - 写锁，事务对数据对象上锁后，可读取和修改该数据对象，其他事务不可再对该数据对象添加锁
  - S锁 共享锁
    - 读锁，某事物对数据对象上锁后，可读取但不可修改该数据对象，其他事务对该数据对象添加s锁，但不能添加x锁
- 封锁协议
  - 一级封锁协议
    - 写前加锁，事务结束释放写锁，防止丢失修改
  - 二级...
    - 写前加写锁，读前加读锁，读完释放读锁，事务结束释放写锁，防止丢失修改和读脏数据
  - 三级...
    - 写前加写锁，读前加读锁，事务结束释放各锁，可防止丢失修改、读脏数据和不可重复读



## Redis
- 内存数据库
- 可以持久化到硬盘
  - 触发命令
      - save 阻塞当前进程 进行持久化
      - bgsave 主进程fork一个子进程来执行RDB过程 完成后自动结束
  - 触发机制
      - 自动触发 
      - 配置redis.conf的自动触发条件
      - shutdown关闭时未开启AOF持久化功能，自动执行一次bgsave
      - 主从同步
      - 手动触发 
  - 持久化类型
      - RDB redis内存快照
        - 文件小 适合定时备份 用于灾难恢复 RDB加载速度也快
        - 实时性差 无法实时持久化 会阻塞进程
      - AOF日志
        - AOF日志是持续增量的备份，是基于写命令存储的可读的文本文件。AOF日志会在持续运行中持续增大，由于Redis重启过程需要优先加载AOF日志进行指令重放以恢复数据，恢复时间会无比漫长。所以需要定期进行AOF重写，对AOF日志进行瘦身。目前AOF是Redis持久化的主流方式。
        - AOF是文件操作，对于变更操作比较密集的server，那么将造成磁盘IO的负荷加重。此外linux对文件操作采取了“延迟写入”手段，即并非每次write操作都会触发实际磁盘操作，而是进入了buffer中，当buffer数据达到阀值时触发实际写入(也有其他时机)，这是linux对文件系统的优化。
        - 优点：AOF只是追加写日志文件，对服务器性能影响较小，速度比RDB要快，消耗的内存较少
        - 缺点：
            - AOF方式生成的日志文件太大，需要不断AOF重写，进行瘦身。
            - 即使经过AOF重写瘦身，由于文件是文本文件，文件体积较大（相比于RDB的二进制文件）。
            - AOF重演命令式的恢复数据，速度显然比RDB要慢。

  - 数据结构
<table>
    <thead><tr>
    <th>类型</th>
    <th>简介</th>
    <th>特性</th>
    <th>场景</th>
    </tr></thead>
    <tbody>
    <tr>
    <td>String(字符串)</td>
    <td>二进制安全</td>
    <td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td>
    <td>简单的缓存/ setnx 用来做简单的锁</td>
    </tr>
    <tr>
    <td>Hash(字典)</td>
    <td>键值对集合,即编程语言中的Map类型</td>
    <td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td>
    <td>存储、读取、修改用户属性</td>
    </tr>
    <tr>
    <td>List(列表)</td>
    <td>链表(双向链表)</td>
    <td>增删快,提供了操作某一段元素的API</td>
    <td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td>
    </tr>
    <tr>
    <td>Set(集合)</td>
    <td>哈希表实现,元素不重复</td>
    <td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td>
    <td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td>
    </tr>
    <tr>
    <td>Sorted Set(有序集合)</td>
    <td>将Set中的元素增加一个权重参数score,元素按score有序排列</td>
    <td>数据插入集合时,已经进行天然排序</td>
    <td>1、排行榜 2、带权重的消息队列</td>
    </tr>
    </tbody>
</table>

## MongoDB
- MongoDB 将数据存储为一个文档，数据结构由键值(key=>value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。
- 优缺点
  - Schema-less，不需要预先定义表结构，同一个“表”中可以保存多个格式的数据；数据支持嵌套，数据以json格式存储
  - Mongodb没有“数据一致性检查”、“事务”等，不适合存储对数据事务要求高（比如金融）的数据；只适合放非关键性数据（比如日志或者缓存）。关联查询很弱，不适合做报表查询
- 应用场景
  - 日志

## ObjectedRelationalMapping ORM
- 为了解决面向对象与关系数据库存在的互不匹配的现象的技术
- 对高级语言内部对象的操作可以转化为sql语句



# 高级语言
## 面向对象特性
## Python特性
## Java特性

## Javascript


# 操作系统应用
## linux指令


# 机器学习
## 相关性分析 R^2
## 线性回归

### 最小二乘法
### 梯度下降法

### 激活函数

### 优化函数

## 人工神经网络
## logistic线性回归

